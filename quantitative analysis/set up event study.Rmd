---
title: "event study"
author: "Devraj Kori"
date: "3/13/2020"
output: html_document
---
Event study possible specification
$$Y_{i,ht} = \sum_{\tau=-q}^m(\beta_{\tau}D^{\tau}_{i,h,t}) + \theta_{h} + \psi_t + \epsilon_{i,h,t}$$

*  $Y_{i,h,t}$ is equal to 1 if individual i in neighborhood h moves in time t.
*  $\tau$ is an event-time indicator which is equal to the difference between year t and the year that the apartment was constructed. 
*  $D_^{\tau}{i,h,t}$ is a set of event-time dummies equal to 1 if individual i in neighborhood h is within the treatment range around the location of the new apartment.
*  $\theta_h$ represents neighborhood fixed-effects
*  $\psi_t$ represents year fixed effects
*  $\epsilon_{i,h,t}$ is the error term, which should be uncorrelated with the other terms. 

* Individuals in the treatment range of an apartment are repeated in the dataset for each event in which they're treated. The original panel dataset, where each row corresponds to individual i in year t, had 76,785 rows. The event study dataset has 87,798 rows. 
* Some rows will be eliminated if we can identify that individuals have been forcibly displaced prior to the construction of an apartment (i.e, if forced out by a landlord to make room for new construction)
* If there is a causal effect of the construction of a new apartment on displacement of nearby voucher residents, then the $\beta_{\tau}$ values will be close to zero for values of $\tau$ less than zero, and will be positive for values of $\tau$ greater than 0.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(dplyr)
library(sf)
library(leaflet)
library(ggmap)
library(rgdal)
library(tidycensus)
library(ggplot2)
library(dummies)
library(estimatr)
```

```{r set_parameters}
#define ring around the apartment that we'll consider the "treatment area"
 #creating a ring so that move-outs from whatever building existed on the same plot of land the apartment is on arent' included

inner_distance<-50%>%units::set_units(m)
outer_distance<-1000%>%units::set_units(m)

#define binning, the maximum number of years before/after an opening to include
years_prior<-(5)
years_after<-(5)

#set Tau to normalize around (Tau that is forced to be 0)
zero_tau=(-1)

#selct neighborhoods to include
included_neighborhoods<-c("East Liberty", "Homewood","Homewood South","Homewood North", "Larimer",
                          "Point Breeze", "East Hills", "Swisshelm Park",
                          "Shadyside", "Squirrel Hill", "Garfield", "Bloomfield", "Highland Park",
                          "Greenfield", "Hazelwood","Glen Hazel", "Lincoln-Lemington-Belmar",
                          "Lower Lawrenceville", "Upper Lawrenceville", "Central Lawrenceville",
                          "Morningside", "Stanton Heights")
#included_neighborhoods<-c("East Liberty","Homewood")
```


```{r load_datasets}
#read in new apartment complex data
new_apartments<-read_csv("New Pgh Apartments - Large market-rate apts since 1999 - cleaned.csv")%>%
  #remove NAS
  filter(!is.na(lon))%>%
  #make it sf object
  st_as_sf(coords=c("lon","lat"),crs = "+init=epsg:4326")

#move the directory up a level (outside "quantitative analysis into main folder)
setwd("..")
load("data preparation/geocode addresses/all recipient addresses geocoded.Rdata",verbose=TRUE)
load("data preparation/all data clean 29-feb-2020.RData",verbose=TRUE)


#load pittsburgh neighborhood shapefile
neighborhoods<-read_sf("data preparation/geocode addresses/Neighborhoods_/Neighborhoods_.shx")%>%
  select(hood,geometry)

#join dat_cleaned5 with 
geocoded_data<-dat_cleaned5%>%
  #remove NA move-outs, since this version is only looking at displacements
  filter(!is.na(MOVEOUTDATE))%>%
  #create the for_geocode_addr column
  mutate(for_geocode_addr = paste(PRIMARYSTREET,ZIP,sep = ", "))%>%
  left_join(correctly_coded%>%
              select(for_geocode_addr))%>%
  select(HA, CLIENT_ID, GENDER, RACE, MOVEINDATE, MOVEOUTDATE, PRIMARYSTREET, ZIP,geometry)%>%
  #make into sf object for join
  st_as_sf(crs = "+init=epsg:4326")%>%
  #join with neighborhoods
  st_join(neighborhoods,join=st_within,left=TRUE)%>%
  unique()%>%
  filter(hood%in%included_neighborhoods)
```

Create a year dataset, where each row corresponds to all of the instances of people living in an apartment in a given year
```{r construct_panel_frame}
year_range<-2003:2019
for(year in year_range){
  year_frame<-geocoded_data%>%
    #create movein and moveout year variables to filter by
    mutate(movein_year=as.numeric(format(MOVEINDATE,"%Y")),
           moveout_year=as.numeric(format(MOVEOUTDATE,"%Y")))%>%
    #filter to only include rows where the stay includes that year
    filter(movein_year<=year & moveout_year<=year)%>%
    #create a flag indicating if they moved out in that year
    mutate(moved_out=(moveout_year==year))%>%
    #remove move-in/move-out fields since they're not relevant in this structure
    select(-c(MOVEINDATE,MOVEOUTDATE,movein_year,moveout_year))%>%
    #add a year column
    mutate(t=year)
  #bind results
  if(year==year_range[1]){
    panel_frame<-year_frame
  }else{
    panel_frame<-rbind(year_frame,panel_frame)
  }
}


```

```{r calculate_apartment_address_distances}
#calculate distances between new apartments and geocoded data
distances<-st_distance(new_apartments$geometry,
                       panel_frame$geometry)

#limit to just addresses that fall within specified range of each new apartment
in_range<-which(distances>=inner_distance & distances<=outer_distance,arr.ind=TRUE)%>%as.data.frame

#remove distances to preserve memory
rm(distances)
```


```{r construct_event_frame, warning=FALSE}
#i<-1
#create a vector of rows in new_apartments
new_apartment_indices<-1:nrow(new_apartments)

#iterate through new apartments
event_frame_function<-function(i,treated){
  #print(i)
  #define apartment date
  apartment_year<-new_apartments[i,]$Opened%>%as.numeric()
  
  #define range of years based on chosen years before/after
  year_range<-(apartment_year-years_prior):(apartment_year+years_after)
  
  #retrieve address indices in range
  voucher_indices_in_range<-in_range[in_range$row==i,]$col
  
  #define rows in treatment, create a tau variable
  treated_rows<-panel_frame%>%
    #limit just to rows in distance range of given event
    slice(voucher_indices_in_range)%>%
    #define tau as difference between t and apartment_year
    mutate(Tau=t-apartment_year)%>%
    # limit only to years in year_range
    filter(t%in%year_range)
  #untreated rows serve as control, so define those too
  untreated_rows<-panel_frame%>%
    #limit just to rows outside distance range of given event
    slice(-voucher_indices_in_range)%>%
    #define tau as 999 (so it can be dropped later)
    mutate(Tau=999)%>%
    # limit only to years in year_range
    filter(t%in%year_range)
  
  #return the binding of the two
  rbind(treated_rows,untreated_rows)
}

#create a function that takes a dataframe as its argument and creates dummies for each tau value
tau_dummies<-function(df){
  #make tau a factor
  df$Tau<-factor(df$Tau)
  #iterate through the levels of Tau, create a dummy in a new frame named "Tau_-x" and bind to df
  #x<-levels(df$Tau)[2]

  for(x in levels(df$Tau)){
    dummy_frame<-data.frame(col=(df$Tau==x))
    #set the name to be "Tau_-x"
    names(dummy_frame)<-paste0("Tau_",x)
    df<-bind_cols(df,dummy_frame)
  }
  df
}

#call event frame function over new_apartment_indices
# using do.call on rbind binds each event's rows together
for_event_study<-do.call(rbind,
                         #lapply calls the function over event indices
                         lapply(new_apartment_indices,event_frame_function))%>%
  #add tau dummies
  tau_dummies()%>%
  #remove the dummy for tau_999
  select(-Tau_999)%>%
  unique()



```

```{r run_event_study}
#create the formula for the event study
taus_list<-c()
for(tau in levels(for_event_study$Tau)){
  taus_list<-c(taus_list,paste0("`Tau_",tau,"`"))
}
#remove taus_list
taus_list<-taus_list[taus_list!="`Tau_999`"]

taus_string<-paste0(taus_list,collapse=" + ")
formula<-as.formula(paste0("moved_out~",taus_string))

test_run<-lm_robust(formula,data=for_event_study,fixed_effects=t+hood)
summary(test_run)
```

```{r plot_test_run_coefficients}

for_normalization<-test_run$coefficients[paste0("`Tau_",zero_tau,"`TRUE")]
data.frame(coefs=test_run$coefficients-for_normalization,
           tau_string=names(test_run$coefficients),
           #specify range as 1.96*sd
           error=test_run$std.error*.196)%>%
  #make tau numeric
  mutate(tau_string=gsub('`','',tau_string),
         tau=as.numeric(gsub('Tau_|TRUE','',tau_string,)))%>%
  ggplot(aes(x=tau,y=coefs))+
  geom_point(aes(x=tau,y=coefs))+
  geom_line()+
  geom_errorbar(aes(ymin=coefs-error,ymax=coefs+error))

```